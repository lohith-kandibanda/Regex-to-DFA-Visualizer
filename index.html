<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regex to Finite Automata Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
        }
        .automaton-container {
            position: relative;
            width: 100%;
            min-height: 400px;
            overflow: auto;
            border: 1px solid #374151; /* border-gray-700 */
            border-radius: 0.5rem;
        }
        .state {
            position: absolute;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: white;
            border: 2px solid #4B5563; /* border-gray-600 */
            background-color: #1F2937; /* bg-gray-800 */
            z-index: 10;
            transition: transform 0.2s, box-shadow 0.2s, background-color 0.3s, border-color 0.3s;
            cursor: grab;
            user-select: none; /* Prevent text selection while dragging */
        }
        .state:active {
            cursor: grabbing;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(96, 165, 250, 0.7);
        }
        .state.start::before {
            content: '▶';
            position: absolute;
            left: -25px;
            font-size: 20px;
            color: #22C55E; /* text-green-500 */
        }
        .state.final {
            border-width: 3px;
            border-color: #3B82F6; /* border-blue-500 */
        }
        .state.final.active {
             box-shadow: 0 0 15px #3B82F6, 0 0 15px #FBBF24;
        }
        .state.active {
            background-color: #FBBF24; /* amber-400 */
            color: #111827;
            border-color: #FBBF24;
        }
        .transition-path {
            transition: stroke 0.3s;
        }
        .transition-path.active {
            stroke: #FBBF24; /* amber-400 */
            stroke-width: 3px;
        }
        .transition-label {
            position: absolute;
            background-color: #374151; /* bg-gray-700 */
            color: #D1D5DB; /* text-gray-300 */
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 11;
            transform: translate(-50%, -50%);
            transition: background-color 0.3s, color 0.3s;
            pointer-events: none; /* So it doesn't interfere with dragging */
        }
        .transition-label.active {
            background-color: #FBBF24;
            color: #111827;
        }
        .result-box {
            padding: 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            text-align: center;
            transition: all 0.3s ease;
        }
        .result-box.accepted {
            background-color: #10B981; /* bg-emerald-500 */
            color: white;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
        }
        .result-box.rejected {
            background-color: #EF4444; /* bg-red-500 */
            color: white;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1F2937; }
        ::-webkit-scrollbar-thumb { background: #4B5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6B7280; }
    </style>
</head>
<body class="text-gray-200 p-4 sm:p-6 md:p-8">

    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-teal-400">
                Finite Automata Visualizer
            </h1>
            <p class="mt-2 text-gray-400">From Regular Expression to Minimized DFA with Interactive Diagrams</p>
        </header>

        <!-- Input Section -->
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
            <label for="regex" class="block text-sm font-medium text-gray-300 mb-2">Regular Expression (use '|' for OR, '*' for Kleene star, '+' for one or more, '?' for zero or one)</label>
            <div class="flex flex-col sm:flex-row gap-4">
                <input type="text" id="regex" class="flex-grow bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 placeholder-gray-400" placeholder="e.g., (a|b)+a?b">
                <button id="convertBtn" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-blue-500">
                    Visualize Automata
                </button>
            </div>
        </div>
        
        <!-- String Test Section -->
        <div id="testSection" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8" style="display: none;">
             <label for="testString" class="block text-sm font-medium text-gray-300 mb-2">Test String</label>
             <div class="flex flex-col sm:flex-row gap-4">
                <input type="text" id="testString" class="flex-grow bg-gray-700 border border-gray-600 rounded-md px-4 py-2 text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 placeholder-gray-400" placeholder="e.g., aabb">
                <button id="checkBtn" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-green-500">
                    Check
                </button>
             </div>
             <div id="stringResult" class="result-box mt-4" style="display: none;"></div>
        </div>


        <!-- Automata Display Section -->
        <div class="space-y-8">
            <div id="nfaSection" class="bg-gray-800 p-6 rounded-lg shadow-lg" style="display: none;">
                <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                    <h2 class="text-2xl font-semibold">NFA (Thompson's Construction)</h2>
                    <button id="animateNfaBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">Animate</button>
                </div>
                <div id="nfa-container" class="automaton-container"></div>
            </div>
            <div id="dfaSection" class="bg-gray-800 p-6 rounded-lg shadow-lg" style="display: none;">
                 <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                    <h2 class="text-2xl font-semibold">DFA (Subset Construction)</h2>
                    <button id="animateDfaBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">Animate</button>
                </div>
                <div id="dfa-container" class="automaton-container"></div>
            </div>
            <div id="minDfaSection" class="bg-gray-800 p-6 rounded-lg shadow-lg" style="display: none;">
                 <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                    <h2 class="text-2xl font-semibold">Minimized DFA</h2>
                    <button id="animateMinDfaBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">Animate</button>
                </div>
                <div id="min-dfa-container" class="automaton-container"></div>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL STATE ---
        let nfa, dfa, minDfa, alphabet;
        const statePositions = { nfa: {}, dfa: {}, minDfa: {} };
        const EPSILON = 'ε';
        let stateCounter = 0;

        // --- CORE LOGIC ---
        
        /**
         * Formats the regex by preprocessing operators like '+' and '?' and adding explicit concatenation dots.
         * The '+' (one or more) and '?' (zero or one) operators are converted into equivalent expressions
         * using the existing operators (*, |).
         * e.g., a+ becomes aa*
         * e.g., a? becomes (a|ε)
         */
        function formatRegex(regex) {
            // Step 1: Pre-process for '+' (one or more) and '?' (zero or one) operators.
            let preprocessedRegex = '';
            for (let i = 0; i < regex.length; i++) {
                const char = regex[i];
                if ((char === '+' || char === '?') && preprocessedRegex.length > 0) {
                    let operand = '';
                    const lastCharOfProcessed = preprocessedRegex[preprocessedRegex.length - 1];

                    if (lastCharOfProcessed === ')') {
                        // Operand is a group, e.g., (a|b). We need to find its matching opening parenthesis.
                        let balance = 0;
                        let j = preprocessedRegex.length - 1;
                        for (; j >= 0; j--) {
                            if (preprocessedRegex[j] === ')') balance++;
                            if (preprocessedRegex[j] === '(') balance--;
                            if (balance === 0) break;
                        }
                        operand = preprocessedRegex.substring(j);
                        preprocessedRegex = preprocessedRegex.substring(0, j); // Remove operand from string
                    } else {
                        // Operand is a single character.
                        operand = lastCharOfProcessed;
                        preprocessedRegex = preprocessedRegex.slice(0, -1); // Remove operand from string
                    }

                    if (char === '+') { // Convert 'a+' to 'aa*'
                        preprocessedRegex += operand + operand + '*';
                    } else { // Convert 'a?' to '(a|ε)'
                        preprocessedRegex += '(' + operand + '|' + EPSILON + ')';
                    }
                } else {
                    preprocessedRegex += char;
                }
            }

            // Step 2: Insert explicit concatenation operator '.'
            let res = '';
            for (let i = 0; i < preprocessedRegex.length; i++) {
                res += preprocessedRegex[i];
                if (i + 1 < preprocessedRegex.length) {
                    const c1 = preprocessedRegex[i];
                    const c2 = preprocessedRegex[i + 1];
                    // A dot is needed between two characters, a char and '(', ')' and a char, ')' and '(', '*' and a char, '*' and '('.
                    if (c1 !== '(' && c1 !== '|' && (c2.match(/[a-zA-Z0-9]/) || c2 === '(' || c2 === EPSILON)) {
                         res += '.';
                    }
                }
            }
            return res;
        }

        function infixToPostfix(regex) { const precedence = { '|': 1, '.': 2, '*': 3 }; let output = ''; const stack = []; for (const char of regex) { if (char.match(/[a-zA-Z0-9]/) || char === EPSILON) { output += char; } else if (char === '(') { stack.push(char); } else if (char === ')') { while (stack.length > 0 && stack[stack.length - 1] !== '(') { output += stack.pop(); } stack.pop(); } else { while (stack.length > 0 && stack[stack.length - 1] !== '(' && precedence[char] <= precedence[stack[stack.length - 1]]) { output += stack.pop(); } stack.push(char); } } while (stack.length > 0) { output += stack.pop(); } return output; }
        function postfixToNfa(postfix) { const stack = []; stateCounter = 0; for (const char of postfix) { if (char.match(/[a-zA-Z0-9]/) || char === EPSILON) { const startState = stateCounter++; const endState = stateCounter++; const nfa = { states: [startState, endState], transitions: { [startState]: { [char]: [endState] } }, startState: startState, finalStates: [endState] }; stack.push(nfa); } else if (char === '.') { const nfa2 = stack.pop(); const nfa1 = stack.pop(); const newTransitions = { ...nfa1.transitions, ...nfa2.transitions }; for (const final of nfa1.finalStates) { newTransitions[final] = { ...newTransitions[final], [EPSILON]: [...(newTransitions[final]?.[EPSILON] || []), nfa2.startState] }; } stack.push({ states: [...nfa1.states, ...nfa2.states], transitions: newTransitions, startState: nfa1.startState, finalStates: nfa2.finalStates }); } else if (char === '|') { const nfa2 = stack.pop(); const nfa1 = stack.pop(); const startState = stateCounter++; const endState = stateCounter++; const newTransitions = { ...nfa1.transitions, ...nfa2.transitions }; newTransitions[startState] = { [EPSILON]: [nfa1.startState, nfa2.startState] }; for (const final of [...nfa1.finalStates, ...nfa2.finalStates]) { newTransitions[final] = { ...newTransitions[final], [EPSILON]: [...(newTransitions[final]?.[EPSILON] || []), endState] }; } stack.push({ states: [startState, endState, ...nfa1.states, ...nfa2.states], transitions: newTransitions, startState: startState, finalStates: [endState] }); } else if (char === '*') { const nfa = stack.pop(); const startState = stateCounter++; const endState = stateCounter++; const newTransitions = { ...nfa.transitions }; newTransitions[startState] = { [EPSILON]: [nfa.startState, endState] }; for (const final of nfa.finalStates) { newTransitions[final] = { ...newTransitions[final], [EPSILON]: [...(newTransitions[final]?.[EPSILON] || []), nfa.startState, endState] }; } stack.push({ states: [startState, endState, ...nfa.states], transitions: newTransitions, startState: startState, finalStates: [endState] }); } } return stack[0]; }
        function epsilonClosure(states, nfaTransitions) { const closure = new Set(states); const stack = [...states]; while (stack.length > 0) { const s = stack.pop(); const epsilonTransitions = nfaTransitions[s]?.[EPSILON] || []; for (const next of epsilonTransitions) { if (!closure.has(next)) { closure.add(next); stack.push(next); } } } return Array.from(closure).sort((a,b) => a-b); }
        function nfaToDfa(nfa, alphabet) { const dfa = { states: [], transitions: {}, startState: null, finalStates: [] }; const dfaStateMap = new Map(); const initialNfaStates = epsilonClosure([nfa.startState], nfa.transitions); const initialDfaStateKey = initialNfaStates.join(','); const queue = [initialNfaStates]; dfaStateMap.set(initialDfaStateKey, 0); dfa.states.push(0); dfa.startState = 0; let dfaStateCounter = 1; while (queue.length > 0) { const currentNfaStates = queue.shift(); const currentDfaStateKey = currentNfaStates.join(','); const currentDfaState = dfaStateMap.get(currentDfaStateKey); if (currentNfaStates.some(s => nfa.finalStates.includes(s))) { dfa.finalStates.push(currentDfaState); } dfa.transitions[currentDfaState] = {}; for (const symbol of alphabet) { let nextNfaStates = []; for (const nfaState of currentNfaStates) { const transitions = nfa.transitions[nfaState]?.[symbol] || []; nextNfaStates.push(...transitions); } if (nextNfaStates.length > 0) { const nextNfaStatesClosure = epsilonClosure(nextNfaStates, nfa.transitions); const nextDfaStateKey = nextNfaStatesClosure.join(','); if (!dfaStateMap.has(nextDfaStateKey)) { dfaStateMap.set(nextDfaStateKey, dfaStateCounter); dfa.states.push(dfaStateCounter); queue.push(nextNfaStatesClosure); dfaStateCounter++; } dfa.transitions[currentDfaState][symbol] = dfaStateMap.get(nextDfaStateKey); } } } return dfa; }
        function minimizeDfa(dfa, alphabet) { let partitions = [dfa.states.filter(s => dfa.finalStates.includes(s)), dfa.states.filter(s => !dfa.finalStates.includes(s))].filter(p => p.length > 0); let changed = true; while (changed) { changed = false; for (const symbol of alphabet) { const newPartitions = []; for (const partition of partitions) { if (partition.length <= 1) { newPartitions.push(partition); continue; } const splits = {}; for (const state of partition) { const targetState = dfa.transitions[state]?.[symbol]; const targetPartitionIndex = partitions.findIndex(p => p.includes(targetState)); const key = targetPartitionIndex !== -1 ? targetPartitionIndex : 'dead'; if (!splits[key]) splits[key] = []; splits[key].push(state); } const splitValues = Object.values(splits); if(splitValues.length > 1) changed = true; newPartitions.push(...splitValues); } partitions = newPartitions; } } const stateMap = {}; partitions.forEach((p, i) => p.forEach(s => stateMap[s] = i)); const minDfa = { states: partitions.map((_, i) => i), transitions: {}, startState: stateMap[dfa.startState], finalStates: [...new Set(dfa.finalStates.map(s => stateMap[s]))] }; partitions.forEach((partition, i) => { const representative = partition[0]; minDfa.transitions[i] = {}; for (const symbol of alphabet) { const target = dfa.transitions[representative]?.[symbol]; if (target !== undefined) { minDfa.transitions[i][symbol] = stateMap[target]; } } }); return minDfa; }
        function simulateDfa(automaton, input) { let currentState = automaton.startState; for (const char of input) { if (automaton.transitions[currentState] && automaton.transitions[currentState][char] !== undefined) { currentState = automaton.transitions[currentState][char]; } else { return false; } } return automaton.finalStates.includes(currentState); }

        // --- UI AND VISUALIZATION LOGIC ---

        function drawAutomaton(automaton, containerId, type) {
            const container = document.getElementById(containerId);
            container.innerHTML = ''; // Clear previous drawing
            
            // Create SVG container for transitions
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.pointerEvents = 'none'; // Let mouse events pass through to states
            container.appendChild(svg);
            
            const stateRadius = 24;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            // Initial layout and state element creation
            const sortedStates = [...new Set(automaton.states)].sort((a,b) => a-b);
            sortedStates.forEach((state, i) => {
                // Only set initial position if not already set (e.g., by dragging)
                if (!statePositions[type][state]) {
                    const angle = (i / sortedStates.length) * 2 * Math.PI;
                    const radius = Math.min(containerWidth / 2 - 60, containerHeight / 2 - 60);
                    const x = containerWidth / 2 + radius * Math.cos(angle);
                    const y = containerHeight / 2 + radius * Math.sin(angle);
                    statePositions[type][state] = { x, y };
                }

                const stateDiv = document.createElement('div');
                stateDiv.className = 'state';
                stateDiv.id = `${containerId}-state-${state}`;
                stateDiv.textContent = state;
                if (state === automaton.startState) stateDiv.classList.add('start');
                if (automaton.finalStates.includes(state)) stateDiv.classList.add('final');
                
                const pos = statePositions[type][state];
                stateDiv.style.left = `${pos.x - stateRadius}px`;
                stateDiv.style.top = `${pos.y - stateRadius}px`;
                
                // Add drag functionality
                makeDraggable(stateDiv, state, automaton, containerId, type);

                container.appendChild(stateDiv);
            });
            
            drawTransitions(automaton, containerId, type);
        }
        
        function drawTransitions(automaton, containerId, type) {
            const container = document.getElementById(containerId);
            const svg = container.querySelector('svg');
            const stateRadius = 24;

            // Clear old transitions and labels
            svg.innerHTML = ''; // Easiest way to clear
            container.querySelectorAll('.transition-label').forEach(l => l.remove());

            // Add marker definition to SVG
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', `arrow-${containerId}`);
            marker.setAttribute('viewBox', '0 -5 10 10');
            marker.setAttribute('refX', '8');
            marker.setAttribute('refY', '0');
            marker.setAttribute('markerWidth', '6');
            marker.setAttribute('markerHeight', '6');
            marker.setAttribute('orient', 'auto');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M0,-5L10,0L0,5');
            path.setAttribute('fill', '#9CA3AF');
            marker.appendChild(path);
            defs.appendChild(marker);
            svg.appendChild(defs);

            const transitionGroups = {};
            for (const fromState in automaton.transitions) {
                for (const symbol in automaton.transitions[fromState]) {
                    const toStates = Array.isArray(automaton.transitions[fromState][symbol]) ? automaton.transitions[fromState][symbol] : [automaton.transitions[fromState][symbol]];
                    toStates.forEach(toState => {
                        const key = `${fromState}-${toState}`;
                        if (!transitionGroups[key]) transitionGroups[key] = [];
                        transitionGroups[key].push(symbol);
                    });
                }
            }

            for (const key in transitionGroups) {
                const [fromState, toState] = key.split('-').map(Number);
                const symbols = transitionGroups[key].join(',');
                const fromPos = statePositions[type][fromState];
                const toPos = statePositions[type][toState];
                if (!fromPos || !toPos) continue;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.setAttribute('stroke', '#6B7280');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('fill', 'none');
                line.classList.add('transition-path');
                line.id = `${containerId}-transition-${fromState}-${toState}-${symbols.replace(/[^a-zA-Z0-9]/g,'')}`;
                
                let d, labelPos;
                if (fromState === toState) {
                    d = `M ${fromPos.x - stateRadius*0.7}, ${fromPos.y - stateRadius*0.7} A ${stateRadius},${stateRadius} 0 1,1 ${fromPos.x + stateRadius*0.7}, ${fromPos.y - stateRadius*0.7}`;
                    labelPos = { x: fromPos.x, y: fromPos.y - stateRadius * 2 };
                } else {
                    const dx = toPos.x - fromPos.x, dy = toPos.y - fromPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const nx = dx / dist, ny = dy / dist;
                    const startX = fromPos.x + nx * stateRadius, startY = fromPos.y + ny * stateRadius;
                    const endX = toPos.x - nx * (stateRadius + 5), endY = toPos.y - ny * (stateRadius + 5);
                    
                    const reverseKey = `${toState}-${fromState}`;
                    if (transitionGroups[reverseKey]) {
                        const curve = 30;
                        d = `M ${startX},${startY} Q ${(startX+endX)/2 + ny*curve},${(startY+endY)/2 - nx*curve} ${endX},${endY}`;
                        labelPos = { x: (startX+endX)/2 + ny*(curve+5), y: (startY+endY)/2 - nx*(curve+5) };
                    } else {
                        d = `M ${startX},${startY} L ${endX},${endY}`;
                        labelPos = { x: (startX+endX)/2, y: (startY+endY)/2 };
                    }
                }
                line.setAttribute('marker-end', `url(#arrow-${containerId})`);
                line.setAttribute('d', d);
                svg.appendChild(line);

                const label = document.createElement('div');
                label.className = 'transition-label';
                label.id = `${containerId}-label-${fromState}-${toState}-${symbols.replace(/[^a-zA-Z0-9]/g,'')}`;
                label.textContent = symbols;
                label.style.left = `${labelPos.x}px`;
                label.style.top = `${labelPos.y}px`;
                container.appendChild(label);
            }
        }

        function makeDraggable(element, stateId, automaton, containerId, type) {
            let offsetX, offsetY;

            function onMouseMove(e) {
                e.preventDefault();
                const containerRect = element.parentElement.getBoundingClientRect();
                let newX = e.clientX - offsetX - containerRect.left;
                let newY = e.clientY - offsetY - containerRect.top;
                
                // Constrain within the container
                newX = Math.max(24, Math.min(containerRect.width - 24, newX));
                newY = Math.max(24, Math.min(containerRect.height - 24, newY));

                element.style.left = `${newX - 24}px`;
                element.style.top = `${newY - 24}px`;
                statePositions[type][stateId] = { x: newX, y: newY };
                drawTransitions(automaton, containerId, type);
            }

            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            element.addEventListener('mousedown', (e) => {
                e.preventDefault();
                offsetX = e.clientX - element.getBoundingClientRect().left;
                offsetY = e.clientY - element.getBoundingClientRect().top;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function clearAllHighlights() { document.querySelectorAll('.state.active, .transition-path.active, .transition-label.active').forEach(el => el.classList.remove('active')); }
        const sleep = ms => new Promise(res => setTimeout(res, ms));

        async function animateDfa(automaton, input, containerId) { clearAllHighlights(); let currentState = automaton.startState; document.getElementById(`${containerId}-state-${currentState}`)?.classList.add('active'); await sleep(800); for (const char of input) { const nextState = automaton.transitions[currentState]?.[char]; const symbols = Object.keys(automaton.transitions[currentState] || {}).find(s => automaton.transitions[currentState][s] === nextState); const pathEl = document.getElementById(`${containerId}-transition-${currentState}-${nextState}-${symbols?.replace(/[^a-zA-Z0-9]/g,'')}`); const labelEl = document.getElementById(`${containerId}-label-${currentState}-${nextState}-${symbols?.replace(/[^a-zA-Z0-9]/g,'')}`); if (pathEl) pathEl.classList.add('active'); if (labelEl) labelEl.classList.add('active'); await sleep(800); document.getElementById(`${containerId}-state-${currentState}`)?.classList.remove('active'); if (pathEl) pathEl.classList.remove('active'); if (labelEl) labelEl.classList.remove('active'); if (nextState === undefined) return false; currentState = nextState; document.getElementById(`${containerId}-state-${currentState}`)?.classList.add('active'); await sleep(800); } return automaton.finalStates.includes(currentState); }
        async function animateNfa(automaton, input, containerId) { clearAllHighlights(); let currentStates = epsilonClosure([automaton.startState], automaton.transitions); currentStates.forEach(s => document.getElementById(`${containerId}-state-${s}`)?.classList.add('active')); await sleep(800); for(const char of input) { let nextStatesDirect = []; for(const state of currentStates) { const transitions = automaton.transitions[state]?.[char] || []; for(const next of transitions) { nextStatesDirect.push(next); const symbols = char; document.getElementById(`${containerId}-transition-${state}-${next}-${symbols.replace(/[^a-zA-Z0-9]/g,'')}`)?.classList.add('active'); document.getElementById(`${containerId}-label-${state}-${next}-${symbols.replace(/[^a-zA-Z0-9]/g,'')}`)?.classList.add('active'); } } await sleep(800); currentStates.forEach(s => document.getElementById(`${containerId}-state-${s}`)?.classList.remove('active')); clearAllHighlights(); if(nextStatesDirect.length === 0) return false; currentStates = epsilonClosure(nextStatesDirect, automaton.transitions); currentStates.forEach(s => document.getElementById(`${containerId}-state-${s}`)?.classList.add('active')); await sleep(800); } return currentStates.some(s => automaton.finalStates.includes(s)); }

        // --- EVENT LISTENERS ---
        document.getElementById('convertBtn').addEventListener('click', () => {
            const regex = document.getElementById('regex').value;
            if (!regex) { alert("Please enter a regular expression."); return; }

            try {
                // Reset positions for new conversion
                statePositions.nfa = {}; statePositions.dfa = {}; statePositions.minDfa = {};

                const formattedRegex = formatRegex(regex);
                const postfix = infixToPostfix(formattedRegex);
                nfa = postfixToNfa(postfix);

                // Build alphabet directly from NFA transitions
                alphabet = [];
                for (const s in nfa.transitions) {
                  for (const sym in nfa.transitions[s]) {
                    if (sym !== EPSILON && !alphabet.includes(sym)) {
                      alphabet.push(sym);
                    }
                  }
                }
                
                dfa = nfaToDfa(nfa, alphabet);
                minDfa = minimizeDfa(dfa, alphabet);

                document.getElementById('nfaSection').style.display = 'block';
                drawAutomaton(nfa, 'nfa-container', 'nfa');
                document.getElementById('dfaSection').style.display = 'block';
                drawAutomaton(dfa, 'dfa-container', 'dfa');
                document.getElementById('minDfaSection').style.display = 'block';
                drawAutomaton(minDfa, 'min-dfa-container', 'minDfa');
                
                document.getElementById('testSection').style.display = 'block';
                document.getElementById('stringResult').style.display = 'none';

            } catch (error) {
                console.error("Error during conversion:", error);
                alert("An error occurred. Please check your regular expression syntax. Details: " + error.message);
            }
        });
        
        document.getElementById('checkBtn').addEventListener('click', () => {
            const testString = document.getElementById('testString').value;
            const resultBox = document.getElementById('stringResult');
            if (!minDfa) { alert("Please generate the automata first."); return; }
            clearAllHighlights();
            const isAccepted = simulateDfa(minDfa, testString);
            resultBox.textContent = isAccepted ? `String "${testString}" is Accepted` : `String "${testString}" is Rejected`;
            resultBox.className = 'result-box mt-4 ' + (isAccepted ? 'accepted' : 'rejected');
            resultBox.style.display = 'block';
        });

        async function handleAnimation(automaton, input, containerId, buttonId, type) {
            const button = document.getElementById(buttonId);
            if (!automaton) { alert("Please generate the automata first."); return; }
            
            button.disabled = true;
            button.textContent = 'Animating...';
            
            let isAccepted;
            if (type === 'nfa') {
                isAccepted = await animateNfa(automaton, input, containerId);
            } else {
                isAccepted = await animateDfa(automaton, input, containerId);
            }

            const resultBox = document.getElementById('stringResult');
            resultBox.textContent = isAccepted ? `String "${input}" is Accepted` : `String "${input}" is Rejected`;
            resultBox.className = 'result-box mt-4 ' + (isAccepted ? 'accepted' : 'rejected');
            resultBox.style.display = 'block';
            
            button.disabled = false;
            button.textContent = 'Animate';
        }

        document.getElementById('animateNfaBtn').addEventListener('click', () => {
            const testString = document.getElementById('testString').value;
            handleAnimation(nfa, testString, 'nfa-container', 'animateNfaBtn', 'nfa');
        });
        document.getElementById('animateDfaBtn').addEventListener('click', () => {
            const testString = document.getElementById('testString').value;
            handleAnimation(dfa, testString, 'dfa-container', 'animateDfaBtn', 'dfa');
        });
        document.getElementById('animateMinDfaBtn').addEventListener('click', () => {
            const testString = document.getElementById('testString').value;
            handleAnimation(minDfa, testString, 'min-dfa-container', 'animateMinDfaBtn', 'minDfa');
        });

    </script>
</body>
</html>

